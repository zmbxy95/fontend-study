## 谈谈你是如何理解JS异步编程的？
同步行为和一部行为，本身就是一个对立统一的概念，Javascript语言更是如此。
单说异步行为，可以说是为了优化因计算量大而时间长的操作，可以在等待其他操作完成的同时，保持其他的程序正常运行，更宽范的说就是，所有不想等待的操作，都是异步行为。

相较于同步代码的执行顺序已知，执行结果可推测，异步执行的代码更像是一个"黑盒子"行为，也就是无法预知的。而如何让后续代码能够使用异步结果而不必刻意等待结果，Javascript在实现这一过程中也是经历了数次迭代。

在早期的Javascript实现中，只支持回调函数来表明异步操作完成（配合setTimeout实现），而这时，带来的串联多个异步操作导的深度嵌套的回调函数（俗称"回调地狱"，emmm~ 可以理解为if或者for循环地狱级别嵌套那种的）问题，当然这里面包括了异步返回值的处理、失败的处理、嵌套异步回调等。

随着Javascript语言的发展，一种更优雅的异步编程方式也逐步到成熟，即Promises/A以及后来被ECMAScript 6 所引用的Promises/A+规范。期间也出现过一些其它优秀的异步编程解决方案，当然发展到现在，仍形成了已Promise异步编程为主导的局面，

再到之后Javascript语言层面上的改进，如async/awit的实现等，从此Javascript语言的异步编程逐步完善。
## EventLoop、消息队列都是做什么的？
首先需要明确的一点是：Javascript的异步编程机制是单线程事件循环模型。

那么见名思意，EventLoop就是事件循环，而与事件循环相配套的就是消息队列。

其中消息队列中存放的是待执行的指令/程序，而EventLoop就是循环检测消息队列，然后依次将它们压栈执行。

## 什么是宏任务，什么是微任务？
宏任务，从程序的角度来理解，就是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），微任务则可以理解为当前Task的内部额外任务，它会在当前Task执行结束后立即执行，再下一个Task前执行。

用一个简单的例子就是我们去银行办理业务需要排队，而每一个人都相当于有一个任务，也就是宏任务，而当前正在办理业务的人，理解为当前正在执行的Task，通常我们办理完一个业务后，银行柜台会询问我们是否还有有其他的业务需要办理，而这些额外的业务，就属于微任务。

用一个流程说明如下：
- 1. 执行一个宏任务
- 2. 宏任务执行结束
- 3. 是否有微任务？
    - 如果有微任务，执行微任务。
    - 如果没有微任务，结束当前宏任务。
- 4.执行下一个宏任务。